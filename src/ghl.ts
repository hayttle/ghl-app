import axios, {InternalAxiosRequestConfig} from "axios"
import {createDecipheriv, createHash} from "node:crypto"
import qs from "qs"

import {Model, TokenType, IntegrationStatus} from "./model"

export class GHL {
  public model: Model

  constructor() {
    this.model = new Model()
  }

  async authorizationHandler(code: string, instanceName?: string, tag?: string) {
    if (!code) {
      console.warn("Please provide code when making call to authorization Handler")
    }

    if (!instanceName) {
      console.error("‚ùå ERRO: instanceName √© obrigat√≥rio para configura√ß√£o da inst√¢ncia Evolution!")
      console.error("‚ùå Para corrigir:")
      console.error("   1. Inclua instanceName na URL de instala√ß√£o")
      console.error(
        "   2. Exemplo: https://marketplace.gohighlevel.com/install?appId=XXX&locationId=YYY&instanceName=ZZZ"
      )
      throw new Error("instanceName √© obrigat√≥rio para configura√ß√£o da inst√¢ncia Evolution")
    }

    // Logs de autoriza√ß√£o simplificados
    console.log(`üîê Iniciando autoriza√ß√£o com instanceName: ${instanceName}${tag ? ` e tag: ${tag}` : ""}`)
    await this.generateAccessTokenRefreshTokenPair(code, instanceName, tag)
  }

  decryptSSOData(key: string) {
    try {
      const blockSize = 16
      const keySize = 32
      const ivSize = 16
      const saltSize = 8

      const rawEncryptedData = Buffer.from(key, "base64")
      const salt = rawEncryptedData.subarray(saltSize, blockSize)
      const cipherText = rawEncryptedData.subarray(blockSize)

      let result = Buffer.alloc(0, 0)
      while (result.length < keySize + ivSize) {
        const hasher = createHash("md5")
        result = Buffer.concat([
          result,
          hasher
            .update(
              Buffer.concat([
                result.subarray(-ivSize),
                Buffer.from(process.env.GHL_APP_SSO_KEY as string, "utf-8"),
                salt
              ])
            )
            .digest()
        ])
      }

      const decipher = createDecipheriv(
        "aes-256-cbc",
        result.subarray(0, keySize),
        result.subarray(keySize, keySize + ivSize)
      )

      const decrypted = decipher.update(cipherText)
      const finalDecrypted = Buffer.concat([decrypted, decipher.final()])
      return JSON.parse(finalDecrypted.toString())
    } catch (error) {
      console.error("Error decrypting SSO data:", error)
      throw error
    }
  }

  requests(resourceId: string) {
    const baseUrl = process.env.GHL_API_DOMAIN
    const model = this.model

    const axiosInstance = axios.create({
      baseURL: baseUrl
    })

    axiosInstance.interceptors.request.use(async (requestConfig: InternalAxiosRequestConfig) => {
      try {
        requestConfig.headers["Authorization"] = `${TokenType.Bearer} ${await model.getAccessToken(resourceId)}`
        requestConfig.headers["locationId"] = resourceId
      } catch (e) {
        console.error(e)
      }
      return requestConfig
    })

    axiosInstance.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config
        if (error.response.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true
          await this.refreshAccessToken(resourceId)
          originalRequest.headers.Authorization = `Bearer ${await model.getAccessToken(resourceId)}`
          return axios(originalRequest)
        }
        return Promise.reject(error)
      }
    )
    return axiosInstance
  }

  async checkInstallationExists(resourceId: string): Promise<boolean> {
    return await this.model.checkInstallationExists(resourceId)
  }

  async deleteInstallationInfo(locationId: string) {
    await this.model.deleteInstallationInfo(locationId)
  }

  async getLocationTokenFromCompanyToken(companyId: string, locationId: string, instanceName?: string) {
    try {
      console.log("üîÑ Obtendo token de localiza√ß√£o para:", {companyId, locationId})

      const res = await this.requests(companyId).post(
        "/oauth/locationToken",
        {
          companyId,
          locationId
        },
        {
          headers: {
            Version: "2021-07-28"
          }
        }
      )

      console.log("üì° Token de localiza√ß√£o obtido com sucesso")

      const installationData = {
        ...res.data,
        locationId: locationId,
        companyId: companyId,
        userType: "Location",
        integrationStatus: "active",
        evolutionInstanceName: instanceName || "default",
        lastSyncAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }

      console.log("üíæ Salvando dados de instala√ß√£o:", {
        locationId: installationData.locationId,
        companyId: installationData.companyId,
        evolutionInstanceName: installationData.evolutionInstanceName
      })

      await this.model.saveInstallationInfo(installationData)

      console.log("‚úÖ Instala√ß√£o de localiza√ß√£o salva com sucesso")
    } catch (error: any) {
      console.error("‚ùå Erro ao obter token de localiza√ß√£o:", error?.response?.data || error)
      throw error
    }
  }

  private async refreshAccessToken(resourceId: string) {
    try {
      console.log("üîÑ Renovando token de acesso para:", resourceId)

      const resp = await axios.post(
        `${process.env.GHL_API_DOMAIN}/oauth/token`,
        qs.stringify({
          client_id: process.env.GHL_APP_CLIENT_ID,
          client_secret: process.env.GHL_APP_CLIENT_SECRET,
          grant_type: "refresh_token",
          refresh_token: await this.model.getRefreshToken(resourceId)
        }),
        {headers: {"content-type": "application/x-www-form-urlencoded"}}
      )

      console.log("üì° Token renovado com sucesso")

      await this.model.saveInstallationInfo({
        ...resp.data,
        locationId: resourceId,
        updatedAt: new Date().toISOString()
      })

      console.log("‚úÖ Token renovado salvo no banco")

      // ‚úÖ NOVO: Verificar se o token renovado tem as permiss√µes necess√°rias
      console.log("üîç Verificando permiss√µes do token renovado...")
      try {
        // ‚úÖ NOVO: Usar chamada direta para evitar loop infinito
        const accessToken = await this.model.getAccessToken(resourceId)
        await axios.get(`${process.env.GHL_API_DOMAIN}/users/me`, {
          headers: {
            Authorization: `Bearer ${accessToken}`,
            locationId: resourceId,
            Version: "2021-07-28"
          }
        })
        console.log("‚úÖ Token renovado tem permiss√µes v√°lidas")
      } catch (testError: any) {
        if (testError.response?.status === 401) {
          console.error("‚ùå Token renovado n√£o tem permiss√µes suficientes")
          console.error("‚ùå Erro:", testError.response?.data?.message || testError.message)
          console.error("üîÑ Solu√ß√£o: Reinstale o app para obter novas permiss√µes")

          // ‚úÖ NOVO: Marcar instala√ß√£o como com erro de permiss√µes
          await this.model.updateIntegrationStatus(resourceId, IntegrationStatus.Error)

          throw new Error("Token renovado n√£o tem permiss√µes suficientes. Reinstale o app.")
        }
        throw testError
      }
    } catch (error: any) {
      console.error("‚ùå Erro ao renovar token:", error?.response?.data || error)
      throw error
    }
  }

  private async generateAccessTokenRefreshTokenPair(code: string, instanceName?: string, tag?: string) {
    try {
      console.log("üîÑ Gerando par de tokens de acesso...")

      const resp = await axios.post(
        `${process.env.GHL_API_DOMAIN}/oauth/token`,
        qs.stringify({
          client_id: process.env.GHL_APP_CLIENT_ID,
          client_secret: process.env.GHL_APP_CLIENT_SECRET,
          grant_type: "authorization_code",
          code
        }),
        {headers: {"content-type": "application/x-www-form-urlencoded"}}
      )

      // ‚úÖ NOVO: Logs detalhados da resposta da API GHL
      console.log("üì° === RESPOSTA COMPLETA DA API GHL ===")
      console.log("üì° Status:", resp.status)
      console.log("üì° Headers:", JSON.stringify(resp.headers, null, 2))
      console.log("üì° Data completa:", JSON.stringify(resp.data, null, 2))
      console.log("üì° ======================================")

      // ‚úÖ NOVO: Logs espec√≠ficos dos campos importantes
      console.log("üîç === CAMPOS IMPORTANTES DA INSTALA√á√ÉO ===")
      console.log("üîç access_token:", resp.data.access_token ? "***CONFIGURADO***" : "N√ÉO CONFIGURADO")
      console.log("üîç refresh_token:", resp.data.refresh_token ? "***CONFIGURADO***" : "N√ÉO CONFIGURADO")
      console.log("üîç token_type:", resp.data.token_type || "N√ÉO CONFIGURADO")
      console.log("üîç expires_in:", resp.data.expires_in || "N√ÉO CONFIGURADO")
      console.log("üîç scope:", resp.data.scope || "N√ÉO CONFIGURADO")
      console.log("üîç locationId:", resp.data.locationId || "N√ÉO CONFIGURADO")
      console.log("üîç companyId:", resp.data.companyId || "N√ÉO CONFIGURADO")
      console.log("üîç conversationProviderId:", resp.data.conversationProviderId || "N√ÉO CONFIGURADO")
      console.log("üîç appId:", resp.data.appId || "N√ÉO CONFIGURADO")
      console.log("üîç userId:", resp.data.userId || "N√ÉO CONFIGURADO")
      console.log("üîç locationName:", resp.data.locationName || "N√ÉO CONFIGURADO")
      console.log("üîç companyName:", resp.data.companyName || "N√ÉO CONFIGURADO")
      console.log("üîç ===========================================")

      // ‚úÖ NOVO: Logs de todos os campos dispon√≠veis
      console.log("üîç === TODOS OS CAMPOS DISPON√çVEIS ===")
      Object.keys(resp.data).forEach((key) => {
        const value = resp.data[key]
        if (typeof value === "string" && value.length > 100) {
          console.log(`üîç ${key}: [STRING LONGA - ${value.length} caracteres]`)
        } else if (typeof value === "object") {
          console.log(`üîç ${key}: [OBJETO] ${JSON.stringify(value, null, 2)}`)
        } else {
          console.log(`üîç ${key}: ${value}`)
        }
      })
      console.log("üîç ======================================")

      // ‚úÖ NOVO: Decodificar JWT token para extrair conversationProviderId
      console.log("üîç === DECODIFICANDO JWT TOKEN ===")

      // Extrai os dados da resposta
      const tokenData = resp.data

      // ‚úÖ CORRE√á√ÉO: ConversationProviderId deve ser configurado manualmente
      // O sourceId do JWT N√ÉO √© o conversationProviderId que precisamos
      console.log("üîç === CONFIGURANDO CONVERSATIONPROVIDERID ===")

      // ‚úÖ OP√á√ÉO 1: Usar vari√°vel de ambiente se configurada
      if (process.env.GHL_CONVERSATION_PROVIDER_ID) {
        tokenData.conversationProviderId = process.env.GHL_CONVERSATION_PROVIDER_ID
        console.log("‚úÖ ConversationProviderId configurado via vari√°vel de ambiente:", tokenData.conversationProviderId)
      } else {
        // ‚úÖ OP√á√ÉO 2: Usar o ID correto identificado pelo usu√°rio
        tokenData.conversationProviderId = "68a1f3cb0547607a9d820805"
        console.log("‚úÖ ConversationProviderId usando ID fixo identificado:", tokenData.conversationProviderId)
        console.log("‚ö†Ô∏è Para personalizar, configure GHL_CONVERSATION_PROVIDER_ID no .env")
      }

      console.log("üîç ======================================")

      // Para integra√ß√£o com Evolution API, precisamos SEMPRE de um locationId
      // O app deve ser instalado diretamente na subconta (location), n√£o na empresa
      if (!tokenData.locationId) {
        console.error("‚ùå ERRO: Esta instala√ß√£o n√£o tem locationId!")
        console.error("‚ùå O app deve ser instalado diretamente na SUBCONTA (location), n√£o na empresa principal")
        console.error("‚ùå Para corrigir:")
        console.error("   1. Desinstale o app da empresa")
        console.error("   2. Instale o app diretamente na subconta desejada")
        console.error("   3. Isso garantir√° que o webhook funcione corretamente")
        throw new Error("App deve ser instalado em subconta (location), n√£o em empresa principal")
      }

      // Se chegou aqui, temos um locationId v√°lido
      const resourceId = tokenData.locationId
      const userType = "Location"

      console.log("üìç Instala√ß√£o de Subconta (Location) detectada ‚úÖ")
      console.log("üìç LocationId:", tokenData.locationId)
      console.log("üìç ResourceId:", resourceId)

      // Prepara dados para salvar
      const installationData = {
        ...tokenData,
        locationId: tokenData.locationId,
        companyId: tokenData.companyId || null,
        userType: userType,
        integrationStatus: "active",
        evolutionInstanceName: instanceName || "default",
        clientId: process.env.GHL_APP_CLIENT_ID,
        clientSecret: process.env.GHL_APP_CLIENT_SECRET,
        tag: tag || null,
        lastSyncAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }

      console.log("üíæ === DADOS QUE SER√ÉO SALVOS NO BANCO ===")
      console.log("üíæ locationId:", installationData.locationId)
      console.log("üíæ companyId:", installationData.companyId)
      console.log("üíæ evolutionInstanceName:", installationData.evolutionInstanceName)
      console.log("üíæ conversationProviderId:", installationData.conversationProviderId)
      console.log("üíæ tag:", installationData.tag)
      console.log("üíæ appId:", installationData.appId)
      console.log("üíæ userId:", installationData.userId)
      console.log("üíæ ===========================================")

      await this.model.saveInstallationInfo(installationData)

      console.log("‚úÖ Instala√ß√£o salva com sucesso para a subconta:", resourceId)
      console.log("üìç LocationId armazenado:", tokenData.locationId)
      console.log("üöÄ Webhook configurado e pronto para receber mensagens!")
    } catch (error: any) {
      console.error("‚ùå Erro ao gerar tokens:", error?.response?.data || error)
      throw error
    }
  }
}
